# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/172X1ZCxek5cNdQ9s536J2FJJXaRPJ02x
"""

!pip install deap

import random
from deap import base, creator, tools, algorithms


def sum_of_different_powers(arr):
    return sum(abs(v) ** (i + 1) for i, v in enumerate(arr, 1)),

# Initialize creator
creator.create("FitnessMin", base.Fitness, weights=(-1.0,))
creator.create("Individual", list, fitness=creator.FitnessMin)

# Initialize toolbox
toolbox = base.Toolbox()
toolbox.register("attr_float", random.uniform, -5, 5)
toolbox.register("individual", tools.initRepeat, creator.Individual, toolbox.attr_float, 10)
toolbox.register("population", tools.initRepeat, list, toolbox.individual)
toolbox.register("mate", tools.cxTwoPoint)
toolbox.register("mutate", tools.mutGaussian, mu=0, sigma=1, indpb=0.1)
toolbox.register("select", tools.selTournament, tournsize=3)
toolbox.register("evaluate", sum_of_different_powers)

# Define parameters
populationSizes = [30, 50, 100, 200]
numsOfGenerations = [10, 50, 100, 500]
crossoverProbabilities = [0.5, 0.6, 0.8, 1.0]
mutationProbabilities = [0.01, 0.05, 0.1, 0.25]


res = []

for populationSize in populationSizes:
  for numOfGenerations in numsOfGenerations:
    for crossoverProbability in crossoverProbabilities:
      for mutationProbability in mutationProbabilities:
        # Get the population
        population = toolbox.population(n=populationSize)
        # Get the final population
        currentResult, _ = algorithms.eaSimple(population, toolbox, cxpb=crossoverProbability, mutpb=mutationProbability, ngen=numOfGenerations, verbose=False)
        # Get the best solution of the population
        bestSolution = tools.selBest(currentResult, k=1)[0]
        # Compute the cost of the best solution
        cost = sum_of_different_powers(bestSolution)
        # Add to the list
        res.append([cost, populationSize, numOfGenerations, crossoverProbability, mutationProbability])
res.sort()
print(res[:10])

from scipy.optimize import differential_evolution

def sum_of_different_powers(arr):
    return sum(abs(v) ** (i + 1) for i, v in enumerate(arr, 1))


# Define parameters
bounds = [(-5, 5)] * 10
populationSizes = [50, 100, 200]
numsOfInterations = [50, 100, 200]
tolerances = [0.01, 0.02, 0.05]
recombinationRates = [0.6, 0.8, 1.0]
mutationRates = [(0.5, 1), (0.75, 1), (0.5, 1.5)]

res = []

for population in populationSizes:
  for iteration in numsOfInterations:
    for tolerance in tolerances:
      for recombination in recombinationRates:
        for mutation in mutationRates:
          # Get the solution
          solution = differential_evolution(
              sum_of_different_powers,
              bounds,
              strategy='best1bin',
              maxiter=iteration,
              popsize=population,
              tol=tolerance,
              mutation=mutation,
              recombination=recombination,
              seed=None
          )
          # Add to the list
          res.append([solution.fun, population, iteration, tolerance, recombination, mutation])
res.sort()
print(res[:10])

!pip install pyswarms

import numpy as np
import pyswarms as ps



def sum_of_different_powers(arr):
  return sum(abs(v) ** (i + 1) for i, v in enumerate(arr, 1))

# Define parameters
optionsList = [{'c1': 1.0, 'c2': 1.0, 'w': 0.15}, {'c1': 1.0, 'c2': 0.5, 'w': 0.15}, {'c1': 0.5, 'c2': 1.0, 'w': 0.15}, {'c1': 0.5, 'c2': 0.5, 'w': 0.15}, {'c1': 1.0, 'c2': 1.0, 'w': 0.25}]
numsOfParticles = [10, 30, 50, 100, 200]
numsOfIterations = [50, 100, 200, 500, 1000]

res = []

for options in optionsList:
  for particles in numsOfParticles:
    for iterations in numsOfIterations:
      # Initialize the bounds
      bounds = (-5 * np.ones(particles), 5 * np.ones(particles))

      # Get the optimizer
      optimizer = ps.single.GlobalBestPSO(n_particles=particles, dimensions=particles, options=options, bounds=bounds)

      # Get the cost
      cost, _ = optimizer.optimize(sum_of_different_powers, iters=iterations)

      # Add to the list
      res.append([cost, options, particles, iterations])

res.sort(key=lambda x: x[0])
print(res[:10])

import random
import numpy as np
from deap import base, creator, tools, algorithms

def zakharov(nums):
    part1 = sum(i * i for i in nums)
    part2 = sum(0.5 * i * v for i, v in enumerate(nums, 1))
    return part1 + part2 ** 2 + part2 ** 4,


# Initialize creator
creator.create("FitnessMin", base.Fitness, weights=(-1.0,))
creator.create("Individual", list, fitness=creator.FitnessMin)

# Initialize toolbox
toolbox = base.Toolbox()
toolbox.register("attr_float", random.uniform, -5, 5)
toolbox.register("individual", tools.initRepeat, creator.Individual, toolbox.attr_float, 10)
toolbox.register("population", tools.initRepeat, list, toolbox.individual)
toolbox.register("mate", tools.cxBlend, alpha=0.4)
toolbox.register("mutate", tools.mutGaussian, mu=0, sigma=1, indpb=0.05)
toolbox.register("select", tools.selTournament, tournsize=3)
toolbox.register("evaluate", zakharov)

# Define parameters
populationSizes = [30, 50, 100, 200]
numsOfGenerations = [10, 50, 100, 500]
crossoverProbabilities = [0.5, 0.6, 0.8, 1.0]
mutationProbabilities = [0.01, 0.05, 0.1, 0.25]


res = []

for populationSize in populationSizes:
  for numOfGenerations in numsOfGenerations:
    for crossoverProbability in crossoverProbabilities:
      for mutationProbability in mutationProbabilities:
        # Get the population
        population = toolbox.population(n=populationSize)
        # Get the final population
        currentResult, _ = algorithms.eaSimple(population, toolbox, cxpb=crossoverProbability, mutpb=mutationProbability, ngen=numOfGenerations, verbose=False)
        # Get the best solution of the population
        bestSolution = tools.selBest(currentResult, k=1)[0]
        # Compute the cost of the best solution
        cost = zakharov(bestSolution)
        # Add to the list
        res.append([cost, populationSize, numOfGenerations, crossoverProbability, mutationProbability])
res.sort()
print(res[:10])

import numpy as np
from scipy.optimize import differential_evolution

def zakharov(nums):
    part1 = sum(i * i for i in nums)
    part2 = sum(0.5 * i * v for i, v in enumerate(nums, 1))
    return part1 + part2 ** 2 + part2 ** 4

# Define the parameters
bounds = [(-5, 5) for _ in range(10)]
populationSizes = [50, 100, 200]
numsOfInterations = [50, 100, 200]
tolerances = [0.01, 0.02, 0.05]
recombinationRates = [0.6, 0.8, 1.0]
mutationRates = [(0.5, 1), (0.75, 1), (0.5, 1.5)]

res = []

for population in populationSizes:
  for iteration in numsOfInterations:
    for tolerance in tolerances:
      for recombination in recombinationRates:
        for mutation in mutationRates:
          # Get the solution
          solution = differential_evolution(
              zakharov,
              bounds,
              strategy='best1bin',
              maxiter=iteration,
              popsize=population,
              tol=tolerance,
              mutation=mutation,
              recombination=recombination,
              seed=None
          )
          # Add to the list
          res.append([solution.fun, population, iteration, tolerance, recombination, mutation])
res.sort()
print(res[:10])

!pip install pyswarms

import numpy as np
import pyswarms as ps

def zakharov_function(nums):
    part1 = sum(i * i for i in nums)
    part2 = sum(0.5 * i * v for i, v in enumerate(nums, 1))
    return part1 + part2 ** 2 + part2 ** 4

# Define parameters
optionsList = [{'c1': 1.0, 'c2': 1.0, 'w': 0.15}, {'c1': 1.0, 'c2': 0.5, 'w': 0.15}, {'c1': 0.5, 'c2': 1.0, 'w': 0.15}, {'c1': 0.5, 'c2': 0.5, 'w': 0.15}, {'c1': 1.0, 'c2': 1.0, 'w': 0.25}]
numsOfParticles = [10, 30, 50, 100, 200]
numsOfIterations = [50, 100, 200, 500, 1000]

res = []

for options in optionsList:
  for particles in numsOfParticles:
    for iterations in numsOfIterations:
      # Initialize the bounds
      bounds = (-5 * np.ones(particles), 5 * np.ones(particles))

      # Get the optimizer
      optimizer = ps.single.GlobalBestPSO(n_particles=particles, dimensions=particles, options=options, bounds=bounds)

      # Get the cost
      cost, _ = optimizer.optimize(zakharov_function, iters=iterations)

      # Add to the list
      res.append([cost, options, particles, iterations])

res.sort(key=lambda x: x[0])
print(res[:10])

import random
import math
from functools import reduce
import operator
from deap import base, creator, tools, algorithms
import numpy as np


def griewank_function(individual):
    part1 = np.sum(np.square(individual)) / 4000
    part2 = np.prod([np.cos(individual[i] / np.sqrt(i + 1)) for i in range(len(individual))])
    return 1 + part1 - part2,

# Initialize creator
creator.create("FitnessMin", base.Fitness, weights=(-1.0,))
creator.create("Individual", list, fitness=creator.FitnessMin)

# Initialize toolbox
toolbox = base.Toolbox()
toolbox.register("attr_float", random.uniform, -5, 5)
toolbox.register("individual", tools.initRepeat, creator.Individual, toolbox.attr_float, n=10)
toolbox.register("population", tools.initRepeat, list, toolbox.individual)
toolbox.register("mate", tools.cxBlend, alpha=0.5)
toolbox.register("mutate", tools.mutGaussian, mu=0, sigma=1, indpb=0.2)
toolbox.register("select", tools.selTournament, tournsize=3)
toolbox.register("evaluate", griewank_function)

# Define parameters
populationSizes = [30, 50, 100, 200]
numsOfGenerations = [10, 50, 100, 500]
crossoverProbabilities = [0.5, 0.6, 0.8, 1.0]
mutationProbabilities = [0.01, 0.05, 0.1, 0.25]


res = []

for populationSize in populationSizes:
  for numOfGenerations in numsOfGenerations:
    for crossoverProbability in crossoverProbabilities:
      for mutationProbability in mutationProbabilities:
        # Get the population
        population = toolbox.population(n=populationSize)
        # Get the final population
        currentResult, _ = algorithms.eaSimple(population, toolbox, cxpb=crossoverProbability, mutpb=mutationProbability, ngen=numOfGenerations, verbose=False)
        # Get the best solution of the population
        bestSolution = tools.selBest(currentResult, k=1)[0]
        # Compute the cost of the best solution
        cost = griewank_function(bestSolution)
        # Add to the list
        res.append([cost, populationSize, numOfGenerations, crossoverProbability, mutationProbability])
res.sort()
print(res[:10])

from scipy.optimize import differential_evolution

def griewank_function(individual):
    part1 = np.sum(np.square(individual)) / 4000
    part2 = np.prod([np.cos(individual[i] / np.sqrt(i + 1)) for i in range(len(individual))])
    return 1 + part1 - part2

# Define the parameters
bounds = [(-5, 5) for _ in range(10)]
populationSizes = [50, 100, 200]
numsOfInterations = [50, 100, 200]
tolerances = [0.01, 0.02, 0.05]
recombinationRates = [0.6, 0.8, 1.0]
mutationRates = [(0.5, 1), (0.75, 1), (0.5, 1.5)]

res = []

for population in populationSizes:
  for iteration in numsOfInterations:
    for tolerance in tolerances:
      for recombination in recombinationRates:
        for mutation in mutationRates:
          # Get the solution
          solution = differential_evolution(
              griewank_function,
              bounds,
              strategy='best1bin',
              maxiter=iteration,
              popsize=population,
              tol=tolerance,
              mutation=mutation,
              recombination=recombination,
              seed=None
          )
          # Add to the list
          res.append([solution.fun, population, iteration, tolerance, recombination, mutation])
res.sort()
print(res[:10])

!pip install pyswarms

import numpy as np
import pyswarms as ps

def griewank_function(individual):
    part1 = np.sum(np.square(individual)) / 4000
    part2 = np.prod([np.cos(individual[i] / np.sqrt(i + 1)) for i in range(len(individual))])
    return 1 + part1 - part2

# Define parameters
optionsList = [{'c1': 1.0, 'c2': 1.0, 'w': 0.15}, {'c1': 1.0, 'c2': 0.5, 'w': 0.15}, {'c1': 0.5, 'c2': 1.0, 'w': 0.15}, {'c1': 0.5, 'c2': 0.5, 'w': 0.15}, {'c1': 1.0, 'c2': 1.0, 'w': 0.25}]
numsOfParticles = [10, 30, 50, 100, 200]
numsOfIterations = [50, 100, 200, 500, 1000]

res = []

for options in optionsList:
  for particles in numsOfParticles:
    for iterations in numsOfIterations:
      # Initialize the bounds
      bounds = (-5 * np.ones(particles), 5 * np.ones(particles))

      # Get the optimizer
      optimizer = ps.single.GlobalBestPSO(n_particles=particles, dimensions=particles, options=options, bounds=bounds)

      # Get the cost
      cost, _ = optimizer.optimize(griewank_function, iters=iterations)

      # Add to the list
      res.append([cost, options, particles, iterations])

res.sort(key=lambda x: x[0])
print(res[:10])

import random
import math
from functools import reduce
import operator
from deap import base, creator, tools, algorithms
import numpy as np


def schwefel(x):
    return 418.9829 * len(x) - np.sum(x * np.sin(np.sqrt(np.abs(x)))),

# Initialize creator
creator.create("FitnessMin", base.Fitness, weights=(-1.0,))
creator.create("Individual", list, fitness=creator.FitnessMin)

# Initialize toolbox
toolbox = base.Toolbox()
toolbox.register("attr_float", random.uniform, -5, 5)
toolbox.register("individual", tools.initRepeat, creator.Individual, toolbox.attr_float, n=10)
toolbox.register("population", tools.initRepeat, list, toolbox.individual)
toolbox.register("mate", tools.cxBlend, alpha=0.5)
toolbox.register("mutate", tools.mutGaussian, mu=0, sigma=1, indpb=0.2)
toolbox.register("select", tools.selTournament, tournsize=3)
toolbox.register("evaluate", schwefel)

# Define parameters
populationSizes = [30, 50, 100, 200]
numsOfGenerations = [10, 50, 100, 500]
crossoverProbabilities = [0.5, 0.6, 0.8, 1.0]
mutationProbabilities = [0.01, 0.05, 0.1, 0.25]


res = []

for populationSize in populationSizes:
  for numOfGenerations in numsOfGenerations:
    for crossoverProbability in crossoverProbabilities:
      for mutationProbability in mutationProbabilities:
        # Get the population
        population = toolbox.population(n=populationSize)
        # Get the final population
        currentResult, _ = algorithms.eaSimple(population, toolbox, cxpb=crossoverProbability, mutpb=mutationProbability, ngen=numOfGenerations, verbose=False)
        # Get the best solution of the population
        bestSolution = tools.selBest(currentResult, k=1)[0]
        # Compute the cost of the best solution
        cost = schwefel(bestSolution)
        # Add to the list
        res.append([cost, populationSize, numOfGenerations, crossoverProbability, mutationProbability])
res.sort()
print(res[:10])

import numpy as np
from scipy.optimize import differential_evolution

def schwefel(x):
    return 418.9829 * len(x) - np.sum(x * np.sin(np.sqrt(np.abs(x))))

# Define the parameters
bounds = [(-5, 5) for _ in range(10)]
populationSizes = [50, 100, 200]
numsOfInterations = [50, 100, 200]
tolerances = [0.01, 0.02, 0.05]
recombinationRates = [0.6, 0.8, 1.0]
mutationRates = [(0.5, 1), (0.75, 1), (0.5, 1.5)]
res = []

for population in populationSizes:
  for iteration in numsOfInterations:
    for tolerance in tolerances:
      for recombination in recombinationRates:
        for mutation in mutationRates:
          # Get the solution
          solution = differential_evolution(
              schwefel,
              bounds,
              strategy='best1bin',
              maxiter=iteration,
              popsize=population,
              tol=tolerance,
              mutation=mutation,
              recombination=recombination,
              seed=None
          )
          # Add to the list
          res.append([solution.fun, population, iteration, tolerance, recombination, mutation])
res.sort()
print(res[:10])

import numpy as np
import pyswarms as ps

def schwefel(x):
    return 418.9829 * len(x) - np.sum(x * np.sin(np.sqrt(np.abs(x))))

# Define parameters
optionsList = [{'c1': 1.0, 'c2': 1.0, 'w': 0.15}, {'c1': 1.0, 'c2': 0.5, 'w': 0.15}, {'c1': 0.5, 'c2': 1.0, 'w': 0.15}, {'c1': 0.5, 'c2': 0.5, 'w': 0.15}, {'c1': 1.0, 'c2': 1.0, 'w': 0.25}]
numsOfParticles = [10, 30, 50, 100, 200]
numsOfIterations = [50, 100, 200, 500, 1000]

res = []

for options in optionsList:
  for particles in numsOfParticles:
    for iterations in numsOfIterations:
      # Initialize the bounds
      bounds = (-5 * np.ones(particles), 5 * np.ones(particles))

      # Get the optimizer
      optimizer = ps.single.GlobalBestPSO(n_particles=particles, dimensions=particles, options=options, bounds=bounds)

      # Get the cost
      cost, _ = optimizer.optimize(schwefel, iters=iterations)

      # Add to the list
      res.append([cost, options, particles, iterations])

res.sort(key=lambda x: x[0])
print(res[:10])

import random
import math
from functools import reduce
import operator
from deap import base, creator, tools, algorithms
import numpy as np


def rastrigin(arr):
    return 10 * len(arr) + np.sum([(xi ** 2 - 10 * np.cos(2 * np.pi * xi)) for xi in arr]),

# Initialize creator
creator.create("FitnessMin", base.Fitness, weights=(-1.0,))
creator.create("Individual", list, fitness=creator.FitnessMin)

# Initialize toolbox
toolbox = base.Toolbox()
toolbox.register("attr_float", random.uniform, -5, 5)
toolbox.register("individual", tools.initRepeat, creator.Individual, toolbox.attr_float, n=10)
toolbox.register("population", tools.initRepeat, list, toolbox.individual)
toolbox.register("mate", tools.cxBlend, alpha=0.5)
toolbox.register("mutate", tools.mutGaussian, mu=0, sigma=1, indpb=0.2)
toolbox.register("select", tools.selTournament, tournsize=3)
toolbox.register("evaluate", rastrigin)

# Define parameters
populationSizes = [30, 50, 100, 200]
numsOfGenerations = [10, 50, 100, 500]
crossoverProbabilities = [0.5, 0.6, 0.8, 1.0]
mutationProbabilities = [0.01, 0.05, 0.1, 0.25]


res = []

for populationSize in populationSizes:
  for numOfGenerations in numsOfGenerations:
    for crossoverProbability in crossoverProbabilities:
      for mutationProbability in mutationProbabilities:
        # Get the population
        population = toolbox.population(n=populationSize)
        # Get the final population
        currentResult, _ = algorithms.eaSimple(population, toolbox, cxpb=crossoverProbability, mutpb=mutationProbability, ngen=numOfGenerations, verbose=False)
        # Get the best solution of the population
        bestSolution = tools.selBest(currentResult, k=1)[0]
        # Compute the cost of the best solution
        cost = rastrigin(bestSolution)
        # Add to the list
        res.append([cost, populationSize, numOfGenerations, crossoverProbability, mutationProbability])
res.sort()
print(res[:10])

import numpy as np
from scipy.optimize import differential_evolution

def rastrigin(arr):
    return 10 * len(arr) + np.sum([(xi ** 2 - 10 * np.cos(2 * np.pi * xi)) for xi in arr])

# Define the parameters
bounds = [(-5, 5) for _ in range(10)]
populationSizes = [50, 100, 200]
numsOfInterations = [50, 100, 200]
tolerances = [0.01, 0.02, 0.05]
recombinationRates = [0.6, 0.8, 1.0]
mutationRates = [(0.5, 1), (0.75, 1), (0.5, 1.5)]

res = []

for population in populationSizes:
  for iteration in numsOfInterations:
    for tolerance in tolerances:
      for recombination in recombinationRates:
        for mutation in mutationRates:
          # Get the solution
          solution = differential_evolution(
              rastrigin,
              bounds,
              strategy='best1bin',
              maxiter=iteration,
              popsize=population,
              tol=tolerance,
              mutation=mutation,
              recombination=recombination,
              seed=None
          )
          # Add to the list
          res.append([solution.fun, population, iteration, tolerance, recombination, mutation])
res.sort()
print(res[:10])

import numpy as np
import pyswarms as ps

def rastrigin(arr):
    return 10 * len(arr) + np.sum([(xi ** 2 - 10 * np.cos(2 * np.pi * xi)) for xi in arr])

# Define parameters
optionsList = [{'c1': 1.0, 'c2': 1.0, 'w': 0.15}, {'c1': 1.0, 'c2': 0.5, 'w': 0.15}, {'c1': 0.5, 'c2': 1.0, 'w': 0.15}, {'c1': 0.5, 'c2': 0.5, 'w': 0.15}, {'c1': 1.0, 'c2': 1.0, 'w': 0.25}]
numsOfParticles = [10, 30, 50, 100, 200]
numsOfIterations = [50, 100, 200, 500, 1000]

res = []

for options in optionsList:
  for particles in numsOfParticles:
    for iterations in numsOfIterations:
      # Initialize the bounds
      bounds = (-5 * np.ones(particles), 5 * np.ones(particles))

      # Get the optimizer
      optimizer = ps.single.GlobalBestPSO(n_particles=particles, dimensions=particles, options=options, bounds=bounds)

      # Get the cost
      cost, _ = optimizer.optimize(rastrigin, iters=iterations)

      # Add to the list
      res.append([cost, options, particles, iterations])

res.sort(key=lambda x: x[0])
print(res[:10])

import random
import math
from functools import reduce
import operator
from deap import base, creator, tools, algorithms
import numpy as np


def sphere(arr):
    return np.sum([xi * xi for xi in arr]),


# Initialize creator
creator.create("FitnessMin", base.Fitness, weights=(-1.0,))
creator.create("Individual", list, fitness=creator.FitnessMin)

# Initialize toolbox
toolbox = base.Toolbox()
toolbox.register("attr_float", random.uniform, -5, 5)
toolbox.register("individual", tools.initRepeat, creator.Individual, toolbox.attr_float, n=10)
toolbox.register("population", tools.initRepeat, list, toolbox.individual)
toolbox.register("mate", tools.cxBlend, alpha=0.5)
toolbox.register("mutate", tools.mutGaussian, mu=0, sigma=1, indpb=0.2)
toolbox.register("select", tools.selTournament, tournsize=3)
toolbox.register("evaluate", sphere)

# Define parameters
populationSizes = [30, 50, 100, 200]
numsOfGenerations = [10, 50, 100, 500]
crossoverProbabilities = [0.5, 0.6, 0.8, 1.0]
mutationProbabilities = [0.01, 0.05, 0.1, 0.25]


res = []

for populationSize in populationSizes:
  for numOfGenerations in numsOfGenerations:
    for crossoverProbability in crossoverProbabilities:
      for mutationProbability in mutationProbabilities:
        # Get the population
        population = toolbox.population(n=populationSize)
        # Get the final population
        currentResult, _ = algorithms.eaSimple(population, toolbox, cxpb=crossoverProbability, mutpb=mutationProbability, ngen=numOfGenerations, verbose=False)
        # Get the best solution of the population
        bestSolution = tools.selBest(currentResult, k=1)[0]
        # Compute the cost of the best solution
        cost = sphere(bestSolution)
        # Add to the list
        res.append([cost, populationSize, numOfGenerations, crossoverProbability, mutationProbability])
res.sort()
print(res[:10])

import numpy as np
from scipy.optimize import differential_evolution

def sphere(arr):
    return np.sum([xi * xi for xi in arr])

# Define the parameters
bounds = [(-5, 5) for _ in range(10)]
populationSizes = [50, 100, 200]
numsOfInterations = [50, 100, 200]
tolerances = [0.01, 0.02, 0.05]
recombinationRates = [0.6, 0.8, 1.0]
mutationRates = [(0.5, 1), (0.75, 1), (0.5, 1.5)]

res = []

for population in populationSizes:
  for iteration in numsOfInterations:
    for tolerance in tolerances:
      for recombination in recombinationRates:
        for mutation in mutationRates:
          # Get the solution
          solution = differential_evolution(
              sphere,
              bounds,
              strategy='best1bin',
              maxiter=iteration,
              popsize=population,
              tol=tolerance,
              mutation=mutation,
              recombination=recombination,
              seed=None
          )
          # Add to the list
          res.append([solution.fun, population, iteration, tolerance, recombination, mutation])
res.sort()
print(res[:10])

import numpy as np
import pyswarms as ps

def sphere(arr):
    return np.sum([xi * xi for xi in arr])

# Define parameters
optionsList = [{'c1': 1.0, 'c2': 1.0, 'w': 0.15}, {'c1': 1.0, 'c2': 0.5, 'w': 0.15}, {'c1': 0.5, 'c2': 1.0, 'w': 0.15}, {'c1': 0.5, 'c2': 0.5, 'w': 0.15}, {'c1': 1.0, 'c2': 1.0, 'w': 0.25}]
numsOfParticles = [10, 30, 50, 100, 200]
numsOfIterations = [50, 100, 200, 500, 1000]

res = []

for options in optionsList:
  for particles in numsOfParticles:
    for iterations in numsOfIterations:
      # Initialize the bounds
      bounds = (-5 * np.ones(particles), 5 * np.ones(particles))

      # Get the optimizer
      optimizer = ps.single.GlobalBestPSO(n_particles=particles, dimensions=particles, options=options, bounds=bounds)

      # Get the cost
      cost, _ = optimizer.optimize(sphere, iters=iterations)

      # Add to the list
      res.append([cost, options, particles, iterations])

res.sort(key=lambda x: x[0])
print(res[:10])

import random
import math
from functools import reduce
import operator
from deap import base, creator, tools, algorithms
import numpy as np


def sum_squares(arr):
    return np.sum([i * xi * xi for i, xi in enumerate(arr, 1)]),

# Initialize creator
creator.create("FitnessMin", base.Fitness, weights=(-1.0,))
creator.create("Individual", list, fitness=creator.FitnessMin)

# Initialize toolbox
toolbox = base.Toolbox()
toolbox.register("attr_float", random.uniform, -5, 5)
toolbox.register("individual", tools.initRepeat, creator.Individual, toolbox.attr_float, n=10)
toolbox.register("population", tools.initRepeat, list, toolbox.individual)
toolbox.register("mate", tools.cxBlend, alpha=0.5)
toolbox.register("mutate", tools.mutGaussian, mu=0, sigma=1, indpb=0.2)
toolbox.register("select", tools.selTournament, tournsize=3)
toolbox.register("evaluate", sum_squares)

# Define parameters
populationSizes = [30, 50, 100, 200]
numsOfGenerations = [10, 50, 100, 500]
crossoverProbabilities = [0.5, 0.6, 0.8, 1.0]
mutationProbabilities = [0.01, 0.05, 0.1, 0.25]


res = []

for populationSize in populationSizes:
  for numOfGenerations in numsOfGenerations:
    for crossoverProbability in crossoverProbabilities:
      for mutationProbability in mutationProbabilities:
        # Get the population
        population = toolbox.population(n=populationSize)
        # Get the final population
        currentResult, _ = algorithms.eaSimple(population, toolbox, cxpb=crossoverProbability, mutpb=mutationProbability, ngen=numOfGenerations, verbose=False)
        # Get the best solution of the population
        bestSolution = tools.selBest(currentResult, k=1)[0]
        # Compute the cost of the best solution
        cost = sum_squares(bestSolution)
        # Add to the list
        res.append([cost, populationSize, numOfGenerations, crossoverProbability, mutationProbability])
res.sort()
print(res[:10])

import numpy as np
from scipy.optimize import differential_evolution

def sum_squares(arr):
    return np.sum([i * xi * xi for i, xi in enumerate(arr, 1)])

# Define the parameters
bounds = [(-5, 5) for _ in range(10)]
populationSizes = [50, 100, 200]
numsOfInterations = [50, 100, 200]
tolerances = [0.01, 0.02, 0.05]
recombinationRates = [0.6, 0.8, 1.0]
mutationRates = [(0.5, 1), (0.75, 1), (0.5, 1.5)]

res = []

for population in populationSizes:
  for iteration in numsOfInterations:
    for tolerance in tolerances:
      for recombination in recombinationRates:
        for mutation in mutationRates:
          # Get the solution
          solution = differential_evolution(
              sum_squares,
              bounds,
              strategy='best1bin',
              maxiter=iteration,
              popsize=population,
              tol=tolerance,
              mutation=mutation,
              recombination=recombination,
              seed=None
          )
          # Add to the list
          res.append([solution.fun, population, iteration, tolerance, recombination, mutation])
res.sort()
print(res[:10])

import numpy as np
import pyswarms as ps

def sum_squares(arr):
    return np.sum([i * xi * xi for i, xi in enumerate(arr, 1)])

# Define parameters
optionsList = [{'c1': 1.0, 'c2': 1.0, 'w': 0.15}, {'c1': 1.0, 'c2': 0.5, 'w': 0.15}, {'c1': 0.5, 'c2': 1.0, 'w': 0.15}, {'c1': 0.5, 'c2': 0.5, 'w': 0.15}, {'c1': 1.0, 'c2': 1.0, 'w': 0.25}]
numsOfParticles = [10, 30, 50, 100, 200]
numsOfIterations = [50, 100, 200, 500, 1000]

res = []

for options in optionsList:
  for particles in numsOfParticles:
    for iterations in numsOfIterations:
      # Initialize the bounds
      bounds = (-5 * np.ones(particles), 5 * np.ones(particles))

      # Get the optimizer
      optimizer = ps.single.GlobalBestPSO(n_particles=particles, dimensions=particles, options=options, bounds=bounds)

      # Get the cost
      cost, _ = optimizer.optimize(sum_squares, iters=iterations)

      # Add to the list
      res.append([cost, options, particles, iterations])

res.sort(key=lambda x: x[0])
print(res[:10])

import random
import math
from functools import reduce
import operator
from deap import base, creator, tools, algorithms
import numpy as np


def trid(arr):
    return np.sum([(xi - 1) ** 2 for xi in arr]) - np.sum([arr[i] * arr[i - 1] for i in range(1, len(arr))]),

# Initialize creator
creator.create("FitnessMin", base.Fitness, weights=(-1.0,))
creator.create("Individual", list, fitness=creator.FitnessMin)

# Initialize toolbox
toolbox = base.Toolbox()
toolbox.register("attr_float", random.uniform, -5, 5)
toolbox.register("individual", tools.initRepeat, creator.Individual, toolbox.attr_float, n=10)
toolbox.register("population", tools.initRepeat, list, toolbox.individual)
toolbox.register("mate", tools.cxBlend, alpha=0.5)
toolbox.register("mutate", tools.mutGaussian, mu=0, sigma=1, indpb=0.2)
toolbox.register("select", tools.selTournament, tournsize=3)
toolbox.register("evaluate", trid)

# Define parameters
populationSizes = [30, 50, 100, 200]
numsOfGenerations = [10, 50, 100, 500]
crossoverProbabilities = [0.5, 0.6, 0.8, 1.0]
mutationProbabilities = [0.01, 0.05, 0.1, 0.25]


res = []

for populationSize in populationSizes:
  for numOfGenerations in numsOfGenerations:
    for crossoverProbability in crossoverProbabilities:
      for mutationProbability in mutationProbabilities:
        # Get the population
        population = toolbox.population(n=populationSize)
        # Get the final population
        currentResult, _ = algorithms.eaSimple(population, toolbox, cxpb=crossoverProbability, mutpb=mutationProbability, ngen=numOfGenerations, verbose=False)
        # Get the best solution of the population
        bestSolution = tools.selBest(currentResult, k=1)[0]
        # Compute the cost of the best solution
        cost = trid(bestSolution)
        # Add to the list
        res.append([cost, populationSize, numOfGenerations, crossoverProbability, mutationProbability])
res.sort()
print(res[:10])

import numpy as np
from scipy.optimize import differential_evolution

def trid(arr):
    return np.sum([(xi - 1) ** 2 for xi in arr]) - np.sum([arr[i] * arr[i - 1] for i in range(1, len(arr))])

# Define the parameters
bounds = [(-5, 5) for _ in range(10)]
populationSizes = [50, 100, 200]
numsOfInterations = [50, 100, 200]
tolerances = [0.01, 0.02, 0.05]
recombinationRates = [0.6, 0.8, 1.0]
mutationRates = [(0.5, 1), (0.75, 1), (0.5, 1.5)]

res = []

for population in populationSizes:
  for iteration in numsOfInterations:
    for tolerance in tolerances:
      for recombination in recombinationRates:
        for mutation in mutationRates:
          # Get the solution
          solution = differential_evolution(
              trid,
              bounds,
              strategy='best1bin',
              maxiter=iteration,
              popsize=population,
              tol=tolerance,
              mutation=mutation,
              recombination=recombination,
              seed=None
          )
          # Add to the list
          res.append([solution.fun, population, iteration, tolerance, recombination, mutation])
res.sort()
print(res[:10])

import numpy as np
import pyswarms as ps

def trid(arr):
    return np.sum([(xi - 1) ** 2 for xi in arr]) - np.sum([arr[i] * arr[i - 1] for i in range(1, len(arr))])

# Define parameters
optionsList = [{'c1': 1.0, 'c2': 1.0, 'w': 0.15}, {'c1': 1.0, 'c2': 0.5, 'w': 0.15}, {'c1': 0.5, 'c2': 1.0, 'w': 0.15}, {'c1': 0.5, 'c2': 0.5, 'w': 0.15}, {'c1': 1.0, 'c2': 1.0, 'w': 0.25}]
numsOfParticles = [10, 30, 50, 100, 200]
numsOfIterations = [50, 100, 200, 500, 1000]

res = []

for options in optionsList:
  for particles in numsOfParticles:
    for iterations in numsOfIterations:
      # Initialize the bounds
      bounds = (-5 * np.ones(particles), 5 * np.ones(particles))

      # Get the optimizer
      optimizer = ps.single.GlobalBestPSO(n_particles=particles, dimensions=particles, options=options, bounds=bounds)

      # Get the cost
      cost, _ = optimizer.optimize(trid, iters=iterations)

      # Add to the list
      res.append([cost, options, particles, iterations])

res.sort(key=lambda x: x[0])
print(res[:10])

import random
import math
from functools import reduce
import operator
from deap import base, creator, tools, algorithms
import numpy as np


def booth(arr):
  x1, x2 = arr
  return (x1 + 2 * x1 - 7) ** 2 + (2 * x1 + x2 - 5) ** 2,

# Initialize creator
creator.create("FitnessMin", base.Fitness, weights=(-1.0,))
creator.create("Individual", list, fitness=creator.FitnessMin)

# Initialize toolbox
toolbox = base.Toolbox()
toolbox.register("attr_float", random.uniform, -10, 10)
toolbox.register("individual", tools.initRepeat, creator.Individual, toolbox.attr_float, n=2)
toolbox.register("population", tools.initRepeat, list, toolbox.individual)
toolbox.register("mate", tools.cxBlend, alpha=0.5)
toolbox.register("mutate", tools.mutGaussian, mu=0, sigma=1, indpb=0.2)
toolbox.register("select", tools.selTournament, tournsize=3)
toolbox.register("evaluate", booth)

# Define parameters
populationSizes = [30, 50, 100, 200]
numsOfGenerations = [10, 50, 100, 500]
crossoverProbabilities = [0.5, 0.6, 0.8, 1.0]
mutationProbabilities = [0.01, 0.05, 0.1, 0.25]


res = []

for populationSize in populationSizes:
  for numOfGenerations in numsOfGenerations:
    for crossoverProbability in crossoverProbabilities:
      for mutationProbability in mutationProbabilities:
        # Get the population
        population = toolbox.population(n=populationSize)
        # Get the final population
        currentResult, _ = algorithms.eaSimple(population, toolbox, cxpb=crossoverProbability, mutpb=mutationProbability, ngen=numOfGenerations, verbose=False)
        # Get the best solution of the population
        bestSolution = tools.selBest(currentResult, k=1)[0]
        # Compute the cost of the best solution
        cost = booth(bestSolution)
        # Add to the list
        res.append([cost, populationSize, numOfGenerations, crossoverProbability, mutationProbability])
res.sort()
print(res[:10])

import numpy as np
from scipy.optimize import differential_evolution

def booth(arr):
  x1, x2 = arr
  return (x1 + 2 * x1 - 7) ** 2 + (2 * x1 + x2 - 5) ** 2

# Define the parameters
bounds = [(-10, 10), (-10, 10)]
populationSizes = [50, 100, 200]
numsOfInterations = [50, 100, 200]
tolerances = [0.01, 0.02, 0.05]
recombinationRates = [0.6, 0.8, 1.0]
mutationRates = [(0.5, 1), (0.75, 1), (0.5, 1.5)]

res = []

for population in populationSizes:
  for iteration in numsOfInterations:
    for tolerance in tolerances:
      for recombination in recombinationRates:
        for mutation in mutationRates:
          # Get the solution
          solution = differential_evolution(
              booth,
              bounds,
              strategy='best1bin',
              maxiter=iteration,
              popsize=population,
              tol=tolerance,
              mutation=mutation,
              recombination=recombination,
              seed=None
          )
          # Add to the list
          res.append([solution.fun, population, iteration, tolerance, recombination, mutation])
res.sort()
print(res[:10])

import numpy as np
import pyswarms as ps

def booth(arr):
  x1 = arr[:, 0]
  x2 = arr[:, 1]
  return (x1 + 2 * x1 - 7) ** 2 + (2 * x1 + x2 - 5) ** 2

# Define parameters
optionsList = [{'c1': 1.0, 'c2': 1.0, 'w': 0.15}, {'c1': 1.0, 'c2': 0.5, 'w': 0.15}, {'c1': 0.5, 'c2': 1.0, 'w': 0.15}, {'c1': 0.5, 'c2': 0.5, 'w': 0.15}, {'c1': 1.0, 'c2': 1.0, 'w': 0.25}]
numsOfParticles = [10, 30, 50, 100, 200]
numsOfIterations = [50, 100, 200, 500, 1000]

res = []

for options in optionsList:
  for particles in numsOfParticles:
    for iterations in numsOfIterations:
      # Initialize the bounds
      bounds = ([-10, -10], [10, 10])

      # Get the optimizer
      optimizer = ps.single.GlobalBestPSO(n_particles=particles, dimensions=2, options=options, bounds=bounds)

      # Get the cost
      cost, _ = optimizer.optimize(booth, iters=iterations)

      # Add to the list
      res.append([cost, options, particles, iterations])

res.sort(key=lambda x: x[0])
print(res[:10])

import random
import math
from functools import reduce
import operator
from deap import base, creator, tools, algorithms
import numpy as np


def michalewicz(arr):
  m = 10
  return -np.sum([np.sin(xi) * np.sin(i * (xi ** 2) / np.pi) ** (2 * m) for i, xi in enumerate(arr, 1)]),

# Initialize creator
creator.create("FitnessMin", base.Fitness, weights=(-1.0,))
creator.create("Individual", list, fitness=creator.FitnessMin)

# Initialize toolbox
toolbox = base.Toolbox()
toolbox.register("attr_float", random.uniform, 0, np.pi)
toolbox.register("individual", tools.initRepeat, creator.Individual, toolbox.attr_float, n=10)
toolbox.register("population", tools.initRepeat, list, toolbox.individual)
toolbox.register("mate", tools.cxBlend, alpha=0.5)
toolbox.register("mutate", tools.mutGaussian, mu=0, sigma=1, indpb=0.2)
toolbox.register("select", tools.selTournament, tournsize=3)
toolbox.register("evaluate", michalewicz)

# Define parameters
populationSizes = [30, 50, 100, 200]
numsOfGenerations = [10, 50, 100, 500]
crossoverProbabilities = [0.5, 0.6, 0.8, 1.0]
mutationProbabilities = [0.01, 0.05, 0.1, 0.25]


res = []

for populationSize in populationSizes:
  for numOfGenerations in numsOfGenerations:
    for crossoverProbability in crossoverProbabilities:
      for mutationProbability in mutationProbabilities:
        # Get the population
        population = toolbox.population(n=populationSize)
        # Get the final population
        currentResult, _ = algorithms.eaSimple(population, toolbox, cxpb=crossoverProbability, mutpb=mutationProbability, ngen=numOfGenerations, verbose=False)
        # Get the best solution of the population
        bestSolution = tools.selBest(currentResult, k=1)[0]
        # Compute the cost of the best solution
        cost = michalewicz(bestSolution)
        # Add to the list
        res.append([cost, populationSize, numOfGenerations, crossoverProbability, mutationProbability])
res.sort()
print(res[:10])

import numpy as np
from scipy.optimize import differential_evolution

def michalewicz(arr):
  m = 10
  return -np.sum([np.sin(xi) * np.sin(i * (xi ** 2) / np.pi) ** (2 * m) for i, xi in enumerate(arr, 1)])

# Define the parameters
bounds = [(-5, 5) for _ in range(10)]
populationSizes = [50, 100, 200]
numsOfInterations = [50, 100, 200]
tolerances = [0.01, 0.02, 0.05]
recombinationRates = [0.6, 0.8, 1.0]
mutationRates = [(0.5, 1), (0.75, 1), (0.5, 1.5)]
res = []

for population in populationSizes:
  for iteration in numsOfInterations:
    for tolerance in tolerances:
      for recombination in recombinationRates:
        for mutation in mutationRates:
          # Get the solution
          solution = differential_evolution(
              michalewicz,
              bounds,
              strategy='best1bin',
              maxiter=iteration,
              popsize=population,
              tol=tolerance,
              mutation=mutation,
              recombination=recombination,
              seed=None
          )
          # Add to the list
          res.append([solution.fun, population, iteration, tolerance, recombination, mutation])
res.sort()
print(res[:10])

import numpy as np
import pyswarms as ps

def michalewicz(arr):
  m = 10
  return -np.sum([np.sin(xi) * np.sin(i * (xi ** 2) / np.pi) ** (2 * m) for i, xi in enumerate(arr, 1)])

# Define parameters
optionsList = [{'c1': 1.0, 'c2': 1.0, 'w': 0.15}, {'c1': 1.0, 'c2': 0.5, 'w': 0.15}, {'c1': 0.5, 'c2': 1.0, 'w': 0.15}, {'c1': 0.5, 'c2': 0.5, 'w': 0.15}, {'c1': 1.0, 'c2': 1.0, 'w': 0.25}]
numsOfParticles = [10, 30, 50, 100, 200]
numsOfIterations = [50, 100, 200, 500, 1000]

res = []

for options in optionsList:
  for particles in numsOfParticles:
    for iterations in numsOfIterations:
      # Initialize the bounds
      bounds = (-5 * np.ones(particles), 5 * np.ones(particles))

      # Get the optimizer
      optimizer = ps.single.GlobalBestPSO(n_particles=particles, dimensions=particles, options=options, bounds=bounds)

      # Get the cost
      cost, _ = optimizer.optimize(michalewicz, iters=iterations)

      # Add to the list
      res.append([cost, options, particles, iterations])

res.sort(key=lambda x: x[0])
print(res[:10])

import random
import math
from functools import reduce
import operator
from deap import base, creator, tools, algorithms
import numpy as np


def matyas(arr):
  x1, x2 = arr
  return 0.26 * (x1 ** 2 + x2 ** 2) - 0.48 * x1 * x2,

# Initialize creator
creator.create("FitnessMin", base.Fitness, weights=(-1.0,))
creator.create("Individual", list, fitness=creator.FitnessMin)

# Initialize toolbox
toolbox = base.Toolbox()
toolbox.register("attr_float", random.uniform, -10, 10)
toolbox.register("individual", tools.initRepeat, creator.Individual, toolbox.attr_float, n=2)
toolbox.register("population", tools.initRepeat, list, toolbox.individual)
toolbox.register("mate", tools.cxBlend, alpha=0.5)
toolbox.register("mutate", tools.mutGaussian, mu=0, sigma=1, indpb=0.2)
toolbox.register("select", tools.selTournament, tournsize=3)
toolbox.register("evaluate", matyas)

# Define parameters
populationSizes = [30, 50, 100, 200]
numsOfGenerations = [10, 50, 100, 500]
crossoverProbabilities = [0.5, 0.6, 0.8, 1.0]
mutationProbabilities = [0.01, 0.05, 0.1, 0.25]


res = []

for populationSize in populationSizes:
  for numOfGenerations in numsOfGenerations:
    for crossoverProbability in crossoverProbabilities:
      for mutationProbability in mutationProbabilities:
        # Get the population
        population = toolbox.population(n=populationSize)
        # Get the final population
        currentResult, _ = algorithms.eaSimple(population, toolbox, cxpb=crossoverProbability, mutpb=mutationProbability, ngen=numOfGenerations, verbose=False)
        # Get the best solution of the population
        bestSolution = tools.selBest(currentResult, k=1)[0]
        # Compute the cost of the best solution
        cost = matyas(bestSolution)
        # Add to the list
        res.append([cost, populationSize, numOfGenerations, crossoverProbability, mutationProbability])
res.sort()
print(res[:10])

import numpy as np
from scipy.optimize import differential_evolution

def matyas(arr):
  x1, x2 = arr
  return 0.26 * (x1 ** 2 + x2 ** 2) - 0.48 * x1 * x2

# Define the parameters
bounds = [(-10, 10), (-10, 10)]
populationSizes = [50, 100, 200]
numsOfInterations = [50, 100, 200]
tolerances = [0.01, 0.02, 0.05]
recombinationRates = [0.6, 0.8, 1.0]
mutationRates = [(0.5, 1), (0.75, 1), (0.5, 1.5)]

res = []

for population in populationSizes:
  for iteration in numsOfInterations:
    for tolerance in tolerances:
      for recombination in recombinationRates:
        for mutation in mutationRates:
          # Get the solution
          solution = differential_evolution(
              matyas,
              bounds,
              strategy='best1bin',
              maxiter=iteration,
              popsize=population,
              tol=tolerance,
              mutation=mutation,
              recombination=recombination,
              seed=None
          )
          # Add to the list
          res.append([solution.fun, population, iteration, tolerance, recombination, mutation])
res.sort()
print(res[:10])

import numpy as np
import pyswarms as ps

def matyas(arr):
  x1 = arr[:, 0]
  x2 = arr[:, 1]
  return 0.26 * (x1 ** 2 + x2 ** 2) - 0.48 * x1 * x2

# Define parameters
optionsList = [{'c1': 1.0, 'c2': 1.0, 'w': 0.15}, {'c1': 1.0, 'c2': 0.5, 'w': 0.15}, {'c1': 0.5, 'c2': 1.0, 'w': 0.15}, {'c1': 0.5, 'c2': 0.5, 'w': 0.15}, {'c1': 1.0, 'c2': 1.0, 'w': 0.25}]
numsOfParticles = [10, 30, 50, 100, 200]
numsOfIterations = [50, 100, 200, 500, 1000]

res = []

for options in optionsList:
  for particles in numsOfParticles:
    for iterations in numsOfIterations:
      # Initialize the bounds
      bounds = ([-10, -10], [10, 10])

      # Get the optimizer
      optimizer = ps.single.GlobalBestPSO(n_particles=particles, dimensions=2, options=options, bounds=bounds)

      # Get the cost
      cost, _ = optimizer.optimize(matyas, iters=iterations)

      # Add to the list
      res.append([cost, options, particles, iterations])

res.sort(key=lambda x: x[0])
print(res[:10])

import random
import math
from functools import reduce
import operator
from deap import base, creator, tools, algorithms
import numpy as np


def mccormick(arr):
  x1, x2 = arr
  return np.sin(x1 + x2) + (x1 - x2) ** 2 - 1.5 * x1 + 2.5 * x2 + 1,

# Initialize creator
creator.create("FitnessMin", base.Fitness, weights=(-1.0,))
creator.create("Individual", list, fitness=creator.FitnessMin)

# Initialize toolbox
toolbox = base.Toolbox()
toolbox.register("attr_float", random.uniform, -10, 10)
toolbox.register("individual", tools.initRepeat, creator.Individual, toolbox.attr_float, n=2)
toolbox.register("population", tools.initRepeat, list, toolbox.individual)
toolbox.register("mate", tools.cxBlend, alpha=0.5)
toolbox.register("mutate", tools.mutGaussian, mu=0, sigma=1, indpb=0.2)
toolbox.register("select", tools.selTournament, tournsize=3)
toolbox.register("evaluate", mccormick)

# Define parameters
populationSizes = [30, 50, 100, 200]
numsOfGenerations = [10, 50, 100, 500]
crossoverProbabilities = [0.5, 0.6, 0.8, 1.0]
mutationProbabilities = [0.01, 0.05, 0.1, 0.25]


res = []

for populationSize in populationSizes:
  for numOfGenerations in numsOfGenerations:
    for crossoverProbability in crossoverProbabilities:
      for mutationProbability in mutationProbabilities:
        # Get the population
        population = toolbox.population(n=populationSize)
        # Get the final population
        currentResult, _ = algorithms.eaSimple(population, toolbox, cxpb=crossoverProbability, mutpb=mutationProbability, ngen=numOfGenerations, verbose=False)
        # Get the best solution of the population
        bestSolution = tools.selBest(currentResult, k=1)[0]
        # Compute the cost of the best solution
        cost = mccormick(bestSolution)
        # Add to the list
        res.append([cost, populationSize, numOfGenerations, crossoverProbability, mutationProbability])
res.sort()
print(res[:10])

import numpy as np
from scipy.optimize import differential_evolution

def mccormick(arr):
  x1, x2 = arr
  return np.sin(x1 + x2) + (x1 - x2) ** 2 - 1.5 * x1 + 2.5 * x2 + 1

# Define the parameters
bounds = [(-10, 10), (-10, 10)]
populationSizes = [50, 100, 200]
numsOfInterations = [50, 100, 200]
tolerances = [0.01, 0.02, 0.05]
recombinationRates = [0.6, 0.8, 1.0]
mutationRates = [(0.5, 1), (0.75, 1), (0.5, 1.5)]

res = []

for population in populationSizes:
  for iteration in numsOfInterations:
    for tolerance in tolerances:
      for recombination in recombinationRates:
        for mutation in mutationRates:
          # Get the solution
          solution = differential_evolution(
              mccormick,
              bounds,
              strategy='best1bin',
              maxiter=iteration,
              popsize=population,
              tol=tolerance,
              mutation=mutation,
              recombination=recombination,
              seed=None
          )
          # Add to the list
          res.append([solution.fun, population, iteration, tolerance, recombination, mutation])
res.sort()
print(res[:10])

import numpy as np
import pyswarms as ps

def mccormick(arr):
  x1 = arr[:, 0]
  x2 = arr[:, 1]
  return np.sin(x1 + x2) + (x1 - x2) ** 2 - 1.5 * x1 + 2.5 * x2 + 1

# Define parameters
optionsList = [{'c1': 1.0, 'c2': 1.0, 'w': 0.15}, {'c1': 1.0, 'c2': 0.5, 'w': 0.15}, {'c1': 0.5, 'c2': 1.0, 'w': 0.15}, {'c1': 0.5, 'c2': 0.5, 'w': 0.15}, {'c1': 1.0, 'c2': 1.0, 'w': 0.25}]
numsOfParticles = [10, 30, 50, 100, 200]
numsOfIterations = [50, 100, 200, 500, 1000]

res = []

for options in optionsList:
  for particles in numsOfParticles:
    for iterations in numsOfIterations:
      # Initialize the bounds
      bounds = ([-10, -10], [10, 10])

      # Get the optimizer
      optimizer = ps.single.GlobalBestPSO(n_particles=particles, dimensions=2, options=options, bounds=bounds)

      # Get the cost
      cost, _ = optimizer.optimize(mccormick, iters=iterations)

      # Add to the list
      res.append([cost, options, particles, iterations])

res.sort(key=lambda x: x[0])
print(res[:10])

!pip install deap
!pip install pyswarms

import random
import math
from functools import reduce
import operator
from deap import base, creator, tools, algorithms
import numpy as np


def cross_in_tray(arr):
  x1, x2 = arr
  return -0.0001 * (abs(np.sin(x1) * np.sin(x2) * np.exp(abs(100 - (x1 ** 2 + x2 ** 2) ** 0.5 / np.pi))) + 1) ** 0.1,


# Initialize creator
creator.create("FitnessMin", base.Fitness, weights=(-1.0,))
creator.create("Individual", list, fitness=creator.FitnessMin)

# Initialize toolbox
toolbox = base.Toolbox()
toolbox.register("attr_float", random.uniform, -10, 10)
toolbox.register("individual", tools.initRepeat, creator.Individual, toolbox.attr_float, n=2)
toolbox.register("population", tools.initRepeat, list, toolbox.individual)
toolbox.register("mate", tools.cxBlend, alpha=0.5)
toolbox.register("mutate", tools.mutGaussian, mu=0, sigma=1, indpb=0.2)
toolbox.register("select", tools.selTournament, tournsize=3)
toolbox.register("evaluate", cross_in_tray)

# Define parameters
populationSizes = [30, 50, 100, 200]
numsOfGenerations = [10, 50, 100, 500]
crossoverProbabilities = [0.5, 0.6, 0.8, 1.0]
mutationProbabilities = [0.01, 0.05, 0.1, 0.25]


res = []

for populationSize in populationSizes:
  for numOfGenerations in numsOfGenerations:
    for crossoverProbability in crossoverProbabilities:
      for mutationProbability in mutationProbabilities:
        # Get the population
        population = toolbox.population(n=populationSize)
        # Get the final population
        currentResult, _ = algorithms.eaSimple(population, toolbox, cxpb=crossoverProbability, mutpb=mutationProbability, ngen=numOfGenerations, verbose=False)
        # Get the best solution of the population
        bestSolution = tools.selBest(currentResult, k=1)[0]
        # Compute the cost of the best solution
        cost = cross_in_tray(bestSolution)
        # Add to the list
        res.append([cost, populationSize, numOfGenerations, crossoverProbability, mutationProbability])
res.sort()
print(res[:10])

import numpy as np
from scipy.optimize import differential_evolution

def cross_in_tray(arr):
  x1, x2 = arr
  return -0.0001 * (abs(np.sin(x1) * np.sin(x2) * np.exp(abs(100 - (x1 ** 2 + x2 ** 2) ** 0.5 / np.pi))) + 1) ** 0.1

# Define the parameters
bounds = [(-10, 10), (-10, 10)]
populationSizes = [50, 100, 200]
numsOfInterations = [50, 100, 200]
tolerances = [0.01, 0.02, 0.05]
recombinationRates = [0.6, 0.8, 1.0]
mutationRates = [(0.5, 1), (0.75, 1), (0.5, 1.5)]

res = []

for population in populationSizes:
  for iteration in numsOfInterations:
    for tolerance in tolerances:
      for recombination in recombinationRates:
        for mutation in mutationRates:
          # Get the solution
          solution = differential_evolution(
              cross_in_tray,
              bounds,
              strategy='best1bin',
              maxiter=iteration,
              popsize=population,
              tol=tolerance,
              mutation=mutation,
              recombination=recombination,
              seed=None
          )
          # Add to the list
          res.append([solution.fun, population, iteration, tolerance, recombination, mutation])
res.sort()
print(res[:10])

import numpy as np
import pyswarms as ps

def cross_in_tray(arr):
  x1 = arr[:, 0]
  x2 = arr[:, 1]
  return -0.0001 * (abs(np.sin(x1) * np.sin(x2) * np.exp(abs(100 - (x1 ** 2 + x2 ** 2) ** 0.5 / np.pi))) + 1) ** 0.1

# Define parameters
optionsList = [{'c1': 1.0, 'c2': 1.0, 'w': 0.15}, {'c1': 1.0, 'c2': 0.5, 'w': 0.15}, {'c1': 0.5, 'c2': 1.0, 'w': 0.15}, {'c1': 0.5, 'c2': 0.5, 'w': 0.15}, {'c1': 1.0, 'c2': 1.0, 'w': 0.25}]
numsOfParticles = [10, 30, 50, 100, 200]
numsOfIterations = [50, 100, 200, 500, 1000]

res = []

for options in optionsList:
  for particles in numsOfParticles:
    for iterations in numsOfIterations:
      # Initialize the bounds
      bounds = ([-10, -10], [10, 10])

      # Get the optimizer
      optimizer = ps.single.GlobalBestPSO(n_particles=particles, dimensions=2, options=options, bounds=bounds)

      # Get the cost
      cost, _ = optimizer.optimize(cross_in_tray, iters=iterations)

      # Add to the list
      res.append([cost, options, particles, iterations])

res.sort(key=lambda x: x[0])
print(res[:10])

import random
import math
from functools import reduce
import operator
from deap import base, creator, tools, algorithms
import numpy as np


def drop_wave(arr):
  x1, x2 = arr
  part1 = 1 + np.cos(12 * (x1 ** 2 + x2 ** 2) ** 0.5)
  part2 = 0.5 * (x1 ** 2 + x2 ** 2) + 2
  return -part1 / part2,


# Initialize creator
creator.create("FitnessMin", base.Fitness, weights=(-1.0,))
creator.create("Individual", list, fitness=creator.FitnessMin)

# Initialize toolbox
toolbox = base.Toolbox()
toolbox.register("attr_float", random.uniform, -5.12, 5.12)
toolbox.register("individual", tools.initRepeat, creator.Individual, toolbox.attr_float, n=2)
toolbox.register("population", tools.initRepeat, list, toolbox.individual)
toolbox.register("mate", tools.cxBlend, alpha=0.5)
toolbox.register("mutate", tools.mutGaussian, mu=0, sigma=1, indpb=0.2)
toolbox.register("select", tools.selTournament, tournsize=3)
toolbox.register("evaluate", drop_wave)

# Define parameters
populationSizes = [30, 50, 100, 200]
numsOfGenerations = [10, 50, 100, 500]
crossoverProbabilities = [0.5, 0.6, 0.8, 1.0]
mutationProbabilities = [0.01, 0.05, 0.1, 0.25]


res = []

for populationSize in populationSizes:
  for numOfGenerations in numsOfGenerations:
    for crossoverProbability in crossoverProbabilities:
      for mutationProbability in mutationProbabilities:
        # Get the population
        population = toolbox.population(n=populationSize)
        # Get the final population
        currentResult, _ = algorithms.eaSimple(population, toolbox, cxpb=crossoverProbability, mutpb=mutationProbability, ngen=numOfGenerations, verbose=False)
        # Get the best solution of the population
        bestSolution = tools.selBest(currentResult, k=1)[0]
        # Compute the cost of the best solution
        cost = drop_wave(bestSolution)
        # Add to the list
        res.append([cost, populationSize, numOfGenerations, crossoverProbability, mutationProbability])
res.sort()
print(res[:10])

import numpy as np
from scipy.optimize import differential_evolution

def drop_wave(arr):
  x1, x2 = arr
  part1 = 1 + np.cos(12 * (x1 ** 2 + x2 ** 2) ** 0.5)
  part2 = 0.5 * (x1 ** 2 + x2 ** 2) + 2
  return -part1 / part2

# Define the parameters
bounds = [(-5.12, 5.12), (-5.12, 5.12)]
populationSizes = [50, 100, 200]
numsOfInterations = [50, 100, 200]
tolerances = [0.01, 0.02, 0.05]
recombinationRates = [0.6, 0.8, 1.0]
mutationRates = [(0.5, 1), (0.75, 1), (0.5, 1.5)]

res = []

for population in populationSizes:
  for iteration in numsOfInterations:
    for tolerance in tolerances:
      for recombination in recombinationRates:
        for mutation in mutationRates:
          # Get the solution
          solution = differential_evolution(
              drop_wave,
              bounds,
              strategy='best1bin',
              maxiter=iteration,
              popsize=population,
              tol=tolerance,
              mutation=mutation,
              recombination=recombination,
              seed=None
          )
          # Add to the list
          res.append([solution.fun, population, iteration, tolerance, recombination, mutation])
res.sort()
print(res[:10])

import numpy as np
import pyswarms as ps


def drop_wave(arr):
  x1 = arr[:, 0]
  x2 = arr[:, 1]
  part1 = 1 + np.cos(12 * (x1 ** 2 + x2 ** 2) ** 0.5)
  part2 = 0.5 * (x1 ** 2 + x2 ** 2) + 2
  return -part1 / part2

# Define parameters
optionsList = [{'c1': 1.0, 'c2': 1.0, 'w': 0.15}, {'c1': 1.0, 'c2': 0.5, 'w': 0.15}, {'c1': 0.5, 'c2': 1.0, 'w': 0.15}, {'c1': 0.5, 'c2': 0.5, 'w': 0.15}, {'c1': 1.0, 'c2': 1.0, 'w': 0.25}]
numsOfParticles = [10, 30, 50, 100, 200]
numsOfIterations = [50, 100, 200, 500, 1000]

res = []

for options in optionsList:
  for particles in numsOfParticles:
    for iterations in numsOfIterations:
      # Initialize the bounds
      bounds = ([-5.12, -5.12], [5.12, 5.12])

      # Get the optimizer
      optimizer = ps.single.GlobalBestPSO(n_particles=particles, dimensions=2, options=options, bounds=bounds)

      # Get the cost
      cost, _ = optimizer.optimize(drop_wave, iters=iterations)

      # Add to the list
      res.append([cost, options, particles, iterations])

res.sort(key=lambda x: x[0])
print(res[:10])

import random
import math
from functools import reduce
import operator
from deap import base, creator, tools, algorithms
import numpy as np


def holder_table(arr):
  x1, x2 = np.clip(arr, -10, 10)
  return -abs(np.sin(x1) * np.cos(x2) * np.exp(abs(1 - (x1 ** 2 + x2 ** 2) ** 0.5 / np.pi))),


# Initialize creator
creator.create("FitnessMin", base.Fitness, weights=(-1.0,))
creator.create("Individual", list, fitness=creator.FitnessMin)

# Initialize toolbox
toolbox = base.Toolbox()
toolbox.register("attr_float", random.uniform, -10, 10)
toolbox.register("individual", tools.initRepeat, creator.Individual, toolbox.attr_float, n=2)
toolbox.register("population", tools.initRepeat, list, toolbox.individual)
toolbox.register("mate", tools.cxBlend, alpha=0.5)
toolbox.register("mutate", tools.mutGaussian, mu=0, sigma=1, indpb=0.2)
toolbox.register("select", tools.selTournament, tournsize=3)
toolbox.register("evaluate", holder_table)

# Define parameters
populationSizes = [30, 50, 100, 200]
numsOfGenerations = [10, 50, 100, 500]
crossoverProbabilities = [0.5, 0.6, 0.8, 1.0]
mutationProbabilities = [0.01, 0.05, 0.1, 0.25]


res = []

for populationSize in populationSizes:
  for numOfGenerations in numsOfGenerations:
    for crossoverProbability in crossoverProbabilities:
      for mutationProbability in mutationProbabilities:
        # Get the population
        population = toolbox.population(n=populationSize)
        # Get the final population
        currentResult, _ = algorithms.eaSimple(population, toolbox, cxpb=crossoverProbability, mutpb=mutationProbability, ngen=numOfGenerations, verbose=False)
        # Get the best solution of the population
        bestSolution = tools.selBest(currentResult, k=1)[0]
        # Compute the cost of the best solution
        cost = holder_table(bestSolution)
        # Add to the list
        res.append([cost, populationSize, numOfGenerations, crossoverProbability, mutationProbability])
res.sort()
print(res[:10])

import numpy as np
from scipy.optimize import differential_evolution

def holder_table(arr):
  x1, x2 = arr
  return -abs(np.sin(x1) * np.cos(x2) * np.exp(abs(1 - (x1 ** 2 + x2 ** 2) ** 0.5 / np.pi)))

# Define the parameters
bounds = [(-10, 10), (-10, 10)]
populationSizes = [50, 100, 200]
numsOfInterations = [50, 100, 200]
tolerances = [0.01, 0.02, 0.05]
recombinationRates = [0.6, 0.8, 1.0]
mutationRates = [(0.5, 1), (0.75, 1), (0.5, 1.5)]

res = []

for population in populationSizes:
  for iteration in numsOfInterations:
    for tolerance in tolerances:
      for recombination in recombinationRates:
        for mutation in mutationRates:
          # Get the solution
          solution = differential_evolution(
              holder_table,
              bounds,
              strategy='best1bin',
              maxiter=iteration,
              popsize=population,
              tol=tolerance,
              mutation=mutation,
              recombination=recombination,
              seed=None
          )
          # Add to the list
          res.append([solution.fun, population, iteration, tolerance, recombination, mutation])
res.sort()
print(res[:10])

import numpy as np
import pyswarms as ps

def holder_table(arr):
  x1 = arr[:, 0]
  x2 = arr[:, 1]
  return -abs(np.sin(x1) * np.cos(x2) * np.exp(abs(1 - (x1 ** 2 + x2 ** 2) ** 0.5 / np.pi)))

# Define parameters
optionsList = [{'c1': 1.0, 'c2': 1.0, 'w': 0.15}, {'c1': 1.0, 'c2': 0.5, 'w': 0.15}, {'c1': 0.5, 'c2': 1.0, 'w': 0.15}, {'c1': 0.5, 'c2': 0.5, 'w': 0.15}, {'c1': 1.0, 'c2': 1.0, 'w': 0.25}]
numsOfParticles = [10, 30, 50, 100, 200]
numsOfIterations = [50, 100, 200, 500, 1000]

res = []

for options in optionsList:
  for particles in numsOfParticles:
    for iterations in numsOfIterations:
      # Initialize the bounds
      bounds = ([-10, -10], [10, 10])

      # Get the optimizer
      optimizer = ps.single.GlobalBestPSO(n_particles=particles, dimensions=2, options=options, bounds=bounds)

      # Get the cost
      cost, _ = optimizer.optimize(holder_table, iters=iterations)

      # Add to the list
      res.append([cost, options, particles, iterations])

res.sort(key=lambda x: x[0])
print(res[:10])